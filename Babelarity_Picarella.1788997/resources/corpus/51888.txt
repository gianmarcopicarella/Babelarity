Xlib (also known as libX11) is an X Window System protocol client library written in the C programming language. It contains functions for interacting with an X server. These functions allow programmers to write programs without knowing the details of the protocol. Few applications use Xlib directly; rather, they employ other libraries that use Xlib functions to provide widget toolkits:
X Toolkit Intrinsics (Xt)
Athena widget set (Xaw)
Motif
FLTK
GTK+
Qt (X11 version)
Tk
SDL (Simple DirectMedia Layer)
SFML (Simple and Fast Multimedia Library)
Xlib appeared around 1985, and is currently used in GUIs for many Unix-like operating systems. The XCB library is an attempt to replace Xlib. While Xlib is still used in some environments, modern versions of the X.org server implement Xlib on top of XCB.
The main types of data in Xlib are the Display structure and the types of the identifiers.
Informally, a display is a physical or virtual device where graphical operations are done. The Display structure of the Xlib library contains information about the display, but more importantly it contains information relative to the channel between the client and the server. For example, in a Unix-like operating system, the Display structure contains the file handle of the socket of this channel (this can be retrieved using the ConnectionNumber macro.) Most Xlib functions have a Display structure as an argument because they either operate on the channel or are relative to a specific channel. In particular, all Xlib functions that interact with the server need this structure for accessing the channel. Some other functions need this structure, even if they operate locally, because they operate on data relative to a specific channel. Operations of this kind include for example operations on the event queue, which is described below.
Windows, colormaps, etc. are managed by the server, which means that the data about their actual implementation is all stored in the server. The client operates on these objects by using their identifiers. The client cannot directly operate on an object, but can only request the server to perform the operation specifying the identifier of the object.
The types Windows, Pixmap, Font, Colormap, etc. are all identifiers, which are 32-bit integers (just as in the X11 protocol itself). A client 'creates' a window by requesting that the server create a window. This is done via a call to an Xlib function that returns an identifier for the window, that is, a number. This identifier can then be used by the client for requesting other operations on the same window to the server.
The identifiers are unique to the server. Most of them can be used by different applications to refer to the same objects. For example, two applications connecting with the same server use the same identifier to refer to the same window. These two applications use two different channels, and therefore have two different Display structures; however, when they request operations on the same identifier, these operations will be done on the same object.
The Xlib functions that send requests to the server usually do not send these requests immediately but store them in a buffer, called the request buffer. The term request in this case refers to the request from the client that is directed to the server: the request buffer can contain all kinds of requests to the server, not only those having a visible effect on the screen. The request buffer is guaranteed to be flushed (i.e., all requests done so far are sent to the server) after a call to the functions XSync or XFlush, after a call to a function that returns a value from the server (these functions block until the answer is received), and in some other conditions.
Xlib stores the received events in a queue. The client application can inspect and retrieve events from the queue. While the X server sends events asynchronously, applications using the Xlib library are required to explicitly call Xlib functions for accessing the events in the queue. Some of these functions may block; in this case, they also flush the request buffer.
Errors are instead received and treated asynchronously: the application can provide an error handler that will be called whenever an error message from the server is received.
The content of a window is not guaranteed to be preserved if the window or one of its parts are made not visible. In this case, the application are sent an Expose event when the window of one part of it is made visible again. The application is then supposed to draw the window content again.
The functions in the Xlib library can be grouped in:
operations on the connection (XOpenDisplay, XCloseDisplay, ...);
requests to the server, including requests for operations (XCreateWindow, XCreateGC,...) and requests for information (XGetWindowProperty, ...); and
operations that are local to the client: operations on the event queue (XNextEvent, XPeekEvent, ...) and other operations on local data (XLookupKeysym, XParseGeometry, XSetRegion, XCreateImage, XSaveContext, ...)
The following program creates a window with a little black square in it.
The client creates a connection with the server by calling XOpenDisplay. It then requests the creation of a window with XCreateSimpleWindow. A separate call to XMapWindow is necessary for mapping the window, that is, for making it visible on the screen.
The square is drawn by calling XFillRectangle. This operation can only be performed after the window is created. However, performing it once may not be enough. Indeed, the content of the window is not always guaranteed to be preserved. For example, if the window is covered and then uncovered again, its content might require being redrawn. The program is informed that the window or a part of it has to be drawn by the reception of an Expose event.
The drawing of the window content is therefore made inside the loop handling the events. Before entering this loop, the events the application is interested in are selected, in this case with XSelectInput. The event loop waits for an incoming event: if this event is a key press, the application exits; if it is an expose event, the window content is drawn. The function XNextEvent blocks and flushes the request buffer if there is no event in the queue.
Xlib does not provide support for buttons, menus, scrollbars, etc. Such widgets are provided by other libraries, which in turn use Xlib. There are two kinds of such libraries:
libraries built atop of the X Toolkit Intrinsics library (Xt), which provides support for widgets but does not provide any particular widget; specific widgets are provided by widget set libraries that use Xt, such as Xaw and Motif;
libraries that provide widget sets using Xlib directly, without the Xt library, such as the X versions of GTK+, Qt, FLTK and fpGUI.
Applications using any of these widget libraries typically specify the content of the window before entering the main loop and do not need to explicitly handle Expose events and redraw the window content.
The XCB library is an alternative to Xlib. Its two main aims are: reduction in library size and direct access to the X11 protocol. A modification of Xlib has been produced to use XCB as a low-level layer.
